{
  "name": "character-parser",
  "version": "2.2.0",
  "description": "Parse JavaScript one character at a time to look for snippets in Templates.  This is not a validator, it's just designed to allow you to have sections of JavaScript delimited by brackets robustly.",
  "main": "index.js",
  "scripts": {
    "coverage": "istanbul cover test/index.js",
    "test": "node test/index.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/ForbesLindesay/character-parser.git"
  },
  "keywords": [
    "parser",
    "JavaScript",
    "bracket",
    "nesting",
    "comment",
    "string",
    "escape",
    "escaping"
  ],
  "author": {
    "name": "ForbesLindesay"
  },
  "license": "MIT",
  "devDependencies": {
    "istanbul": "~0.3.22",
    "testit": "~2.0.2"
  },
  "dependencies": {
    "is-regex": "^1.0.3"
  },
  "readme": "# character-parser\n\nParse JavaScript one character at a time to look for snippets in Templates.  This is not a validator, it's just designed to allow you to have sections of JavaScript delimited by brackets robustly.\n\n[![Build Status](https://img.shields.io/travis/ForbesLindesay/character-parser/master.svg)](https://travis-ci.org/ForbesLindesay/character-parser)\n\n## Installation\n\n    npm install character-parser\n\n## Usage\n\n### Parsing\n\nWork out how much depth changes:\n\n```js\nvar state = parse('foo(arg1, arg2, {\\n  foo: [a, b\\n');\nassert.deepEqual(state.stack, [')', '}', ']']);\n\nparse('    c, d]\\n  })', state);\nassert.deepEqual(state.stack, []);\n```\n\n### Custom Delimited Expressions\n\nFind code up to a custom delimiter:\n\n```js\n// EJS-style\nvar section = parser.parseUntil('foo.bar(\"%>\").baz%> bing bong', '%>');\nassert(section.start === 0);\nassert(section.end === 17); // exclusive end of string\nassert(section.src = 'foo.bar(\"%>\").baz');\n\nvar section = parser.parseUntil('<%foo.bar(\"%>\").baz%> bing bong', '%>', {start: 2});\nassert(section.start === 2);\nassert(section.end === 19); // exclusive end of string\nassert(section.src = 'foo.bar(\"%>\").baz');\n\n// Jade-style\nvar section = parser.parseUntil('#[p= [1, 2][i]]', ']', {start: 2})\nassert(section.start === 2);\nassert(section.end === 14); // exclusive end of string\nassert(section.src === 'p= [1, 2][i]')\n\n// Dumb parsing\n// Stop at first delimiter encountered, doesn't matter if it's nested or not\n// This is the character-parser@1 default behavior.\nvar section = parser.parseUntil('#[p= [1, 2][i]]', '}', {start: 2, ignoreNesting: true})\nassert(section.start === 2);\nassert(section.end === 10); // exclusive end of string\nassert(section.src === 'p= [1, 2')\n''\n```\n\nDelimiters are ignored if they are inside strings or comments.\n\n## API\n\nAll methods may throw an exception in the case of syntax errors. The exception contains an additional `code` property that always starts with `CHARACTER_PARSER:` that is unique for the error.\n\n### parse(str, state = defaultState(), options = {start: 0, end: src.length})\n\nParse a string starting at the index start, and return the state after parsing that string.\n\nIf you want to parse one string in multiple sections you should keep passing the resulting state to the next parse operation.\n\nReturns a `State` object.\n\n### parseUntil(src, delimiter, options = {start: 0, ignoreLineComment: false, ignoreNesting: false})\n\nParses the source until the first occurence of `delimiter` which is not in a string or a comment.\n\nIf `ignoreLineComment` is `true`, it will still count if the delimiter occurs in a line comment.\n\nIf `ignoreNesting` is `true`, it will stop at the first bracket, not taking into account if the bracket part of nesting or not. See example above.\n\nIt returns an object with the structure:\n\n```js\n{\n  start: 0,//index of first character of string\n  end: 13,//index of first character after the end of string\n  src: 'source string'\n}\n```\n\n### parseChar(character, state = defaultState())\n\nParses the single character and returns the state.  See `parse` for the structure of the returned state object.  N.B. character must be a single character not a multi character string.\n\n### defaultState()\n\nGet a default starting state.\n\n### isPunctuator(character)\n\nReturns `true` if `character` represents punctuation in JavaScript.\n\n### isKeyword(name)\n\nReturns `true` if `name` is a keyword in JavaScript.\n\n### TOKEN_TYPES & BRACKETS\n\nObjects whose values can be a frame in the `stack` property of a State (documented below).\n\n## State\n\nA state is an object with the following structure\n\n```js\n{\n  stack: [],          // stack of detected brackets; the outermost is [0]\n  regexpStart: false, // true if a slash is just encountered and a REGEXP state has just been added to the stack\n\n  escaped: false,     // true if in a string and the last character was an escape character\n  hasDollar: false,   // true if in a template string and the last character was a dollar sign\n\n  src: '',            // the concatenated source string\n  history: '',        // reversed `src`\n  lastChar: ''        // last parsed character\n}\n```\n\n`stack` property can contain any of the following:\n\n- Any of the property values of `characterParser.TOKEN_TYPES`\n- Any of the property values of `characterParser.BRACKETS` (the end bracket, not the starting bracket)\n\nIt also has the following useful methods:\n\n- `.current()` returns the innermost bracket (i.e. the last stack frame).\n- `.isString()` returns `true` if the current location is inside a string.\n- `.isComment()` returns `true` if the current location is inside a comment.\n- `.isNesting([opts])` returns `true` if the current location is not at the top level, i.e. if the stack is not empty. If `opts.ignoreLineComment` is `true`, line comments are not counted as a level, so for `// a` it will still return false.\n\n### Errors\n\nAll errors thrown by character-parser has a `code` property attached to it that allows one to identify what sort of error is thrown. For errors thrown from `parse` and `parseUntil`, an additional `index` property is available.\n\n## Transition from v1\n\nIn character-parser@2, we have changed the APIs quite a bit. These are some notes that will help you transition to the new version.\n\n### State Object Changes\n\nInstead of keeping depths of different brackets, we are now keeping a stack. We also removed some properties:\n\n```js\nstate.lineComment  → state.current() === parser.TOKEN_TYPES.LINE_COMMENT\nstate.blockComment → state.current() === parser.TOKEN_TYPES.BLOCK_COMMENT\nstate.singleQuote  → state.current() === parser.TOKEN_TYPES.SINGLE_QUOTE\nstate.doubleQuote  → state.current() === parser.TOKEN_TYPES.DOUBLE_QUOTE\nstate.regexp       → state.current() === parser.TOKEN_TYPES.REGEXP\n```\n\n### `parseMax`\n\nThis function has been removed since the usefulness of this function has been questioned. You should find that `parseUntil` is a better choice for your task.\n\n### `parseUntil`\n\nThe default behavior when the delimiter is a bracket has been changed so that nesting is taken into account to determine if the end is reached.\n\nTo preserve the original behavior, pass `ignoreNesting: true` as an option.\n\nTo see the difference between the new and old behaviors, see the \"Usage\" section earlier.\n\n### `parseMaxBracket`\n\nThis function has been merged into `parseUntil`. You can directly rename the function call without any repercussions.\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/ForbesLindesay/character-parser/issues"
  },
  "homepage": "https://github.com/ForbesLindesay/character-parser#readme",
  "_id": "character-parser@2.2.0",
  "_shasum": "c7ce28f36d4bcd9744e5ffc2c5fcde1c73261fc0",
  "_resolved": "https://registry.npmjs.org/character-parser/-/character-parser-2.2.0.tgz",
  "_from": "character-parser@>=2.1.1 <3.0.0"
}
